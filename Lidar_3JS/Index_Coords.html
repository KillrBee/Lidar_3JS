<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js LIDAR Terrain Viewer with Property Lines</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/proj4@2.9.0/dist/proj4.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #111827; }
        #container { width: 100vw; height: 100vh; display: block; }
        #ui-panel { position: absolute; top: 20px; left: 20px; background-color: rgba(17, 24, 39, 0.8); backdrop-filter: blur(10px); color: white; padding: 20px; border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.1); max-width: 320px; box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37); max-height: 90vh; overflow-y: auto; }
        #loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 1.2rem; display: none; flex-direction: column; align-items: center; gap: 1rem; }
        .spinner { border: 4px solid rgba(255, 255, 255, 0.2); border-left-color: #3b82f6; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 8px; background: #4b5563; border-radius: 5px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: #3b82f6; cursor: pointer; border-radius: 50%; border: 2px solid white; }
        input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; background: #3b82f6; cursor: pointer; border-radius: 50%; border: 2px solid white; }
        select, input[type="number"], input[type="text"] { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e"); background-position: right 0.5rem center; background-repeat: no-repeat; background-size: 1.5em 1.5em; -webkit-appearance: none; -moz-appearance: none; appearance: none; }
        input[type="number"], input[type="text"] { background-image: none; }
        .coordinate-input { font-size: 0.875rem; padding: 0.5rem; }
        .property-corner { background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 0.75rem; margin-bottom: 0.75rem; }
        .error-message { color: #ef4444; font-size: 0.75rem; margin-top: 0.25rem; }
        .success-message { color: #10b981; font-size: 0.75rem; margin-top: 0.25rem; }
    </style>
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
</head>
<body>

    <canvas id="container"></canvas>

    <div id="ui-panel">
        <h1 class="text-xl font-bold mb-2">LIDAR Terrain Controls</h1>
        <p class="text-sm text-gray-400 mb-4">Load your `terrain_data.json` file to begin.</p>
        
        <div class="mb-4">
            <label for="jsonFile" class="block mb-2 text-sm font-medium text-gray-300">Load Terrain Data</label>
            <input type="file" id="jsonFile" accept=".json" class="block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-500 file:text-white hover:file:bg-blue-600 cursor-pointer">
        </div>

        <div id="controls" class="hidden space-y-4">
            <div>
                <label for="verticalExaggeration" class="block mb-2 text-sm font-medium text-gray-300">Vertical Exaggeration: <span id="veValue">1.0</span>x</label>
                <input type="range" id="verticalExaggeration" min="0.1" max="10" step="0.1" value="1.0" class="w-full">
            </div>
             <div>
                <label for="colorScheme" class="block mb-2 text-sm font-medium text-gray-300">Color Scheme</label>
                <select id="colorScheme" class="w-full bg-gray-800 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5">
                    <option value="topographic" selected>Topographic</option>
                    <option value="earth">Earth</option>
                    <option value="grayscale">Grayscale</option>
                    <option value="arctic">Arctic</option>
                    <option value="volcanic">Volcanic</option>
                    <option value="desert">Desert</option>
                </select>
            </div>
            <div class="pt-2 border-t border-gray-700 space-y-4">
                 <div class="flex items-center">
                    <input id="contourToggle" type="checkbox" checked class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500">
                    <label for="contourToggle" class="ml-2 text-sm font-medium text-gray-300">Show Contours</label>
                </div>
                <div>
                    <label for="contourInterval" class="block mb-2 text-sm font-medium text-gray-300">Contour Interval (m)</label>
                    <input type="number" id="contourInterval" value="1" min="1" step="1" class="w-full bg-gray-800 border border-gray-600 text-white text-sm rounded-lg p-2.5">
                </div>
            </div>
            <div class="flex items-center pt-2 border-t border-gray-700">
                <input id="wireframeToggle" type="checkbox" class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500">
                <label for="wireframeToggle" class="ml-2 text-sm font-medium text-gray-300">Show Wireframe</label>
            </div>

            <!-- Property Lines Section -->
            <div class="pt-4 border-t border-gray-700">
                <div class="flex items-center mb-3">
                    <input id="propertyToggle" type="checkbox" class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500">
                    <label for="propertyToggle" class="ml-2 text-sm font-medium text-gray-300">Show Property Lines</label>
                </div>
                
                <div id="propertyControls" class="space-y-3">
                    <div class="property-corner">
                        <label class="block text-xs font-medium text-gray-400 mb-2">Corner 1 (NW)</label>
                        <div class="grid grid-cols-2 gap-2">
                            <input type="text" id="lat1" placeholder="44.75055" class="coordinate-input w-full bg-gray-800 border border-gray-600 text-white text-sm rounded p-2">
                            <input type="text" id="lon1" placeholder="-79.90776" class="coordinate-input w-full bg-gray-800 border border-gray-600 text-white text-sm rounded p-2">
                        </div>
                        <div class="text-xs text-gray-500 mt-1">Latitude, Longitude</div>
                    </div>

                    <div class="property-corner">
                        <label class="block text-xs font-medium text-gray-400 mb-2">Corner 2 (NE)</label>
                        <div class="grid grid-cols-2 gap-2">
                            <input type="text" id="lat2" placeholder="44.75055" class="coordinate-input w-full bg-gray-800 border border-gray-600 text-white text-sm rounded p-2">
                            <input type="text" id="lon2" placeholder="-79.90676" class="coordinate-input w-full bg-gray-800 border border-gray-600 text-white text-sm rounded p-2">
                        </div>
                        <div class="text-xs text-gray-500 mt-1">Latitude, Longitude</div>
                    </div>

                    <div class="property-corner">
                        <label class="block text-xs font-medium text-gray-400 mb-2">Corner 3 (SE)</label>
                        <div class="grid grid-cols-2 gap-2">
                            <input type="text" id="lat3" placeholder="44.74955" class="coordinate-input w-full bg-gray-800 border border-gray-600 text-white text-sm rounded p-2">
                            <input type="text" id="lon3" placeholder="-79.90676" class="coordinate-input w-full bg-gray-800 border border-gray-600 text-white text-sm rounded p-2">
                        </div>
                        <div class="text-xs text-gray-500 mt-1">Latitude, Longitude</div>
                    </div>

                    <div class="property-corner">
                        <label class="block text-xs font-medium text-gray-400 mb-2">Corner 4 (SW)</label>
                        <div class="grid grid-cols-2 gap-2">
                            <input type="text" id="lat4" placeholder="44.74955" class="coordinate-input w-full bg-gray-800 border border-gray-600 text-white text-sm rounded p-2">
                            <input type="text" id="lon4" placeholder="-79.90776" class="coordinate-input w-full bg-gray-800 border border-gray-600 text-white text-sm rounded p-2">
                        </div>
                        <div class="text-xs text-gray-500 mt-1">Latitude, Longitude</div>
                    </div>

                    <div class="space-y-2">
                        <div>
                            <label for="propertyColor" class="block mb-1 text-xs font-medium text-gray-300">Line Color</label>
                            <select id="propertyColor" class="w-full bg-gray-800 border border-gray-600 text-white text-sm rounded p-2">
                                <option value="#ff0000" selected>Red</option>
                                <option value="#00ff00">Green</option>
                                <option value="#0000ff">Blue</option>
                                <option value="#ffff00">Yellow</option>
                                <option value="#ff00ff">Magenta</option>
                                <option value="#00ffff">Cyan</option>
                                <option value="#ffffff">White</option>
                                <option value="#ffa500">Orange</option>
                            </select>
                        </div>
                        <div>
                            <label for="propertyWidth" class="block mb-1 text-xs font-medium text-gray-300">Line Width: <span id="pwValue">3</span>px</label>
                            <input type="range" id="propertyWidth" min="1" max="10" step="1" value="3" class="w-full">
                        </div>
                        <div>
                            <label for="propertyHeight" class="block mb-1 text-xs font-medium text-gray-300">Height Offset: <span id="phValue">2</span>m</label>
                            <input type="range" id="propertyHeight" min="0.5" max="10" step="0.5" value="2" class="w-full">
                        </div>
                    </div>

                    <div class="flex space-x-2">
                        <button id="updateProperty" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium py-2 px-3 rounded">
                            Update Lines
                        </button>
                        <button id="clearProperty" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white text-sm font-medium py-2 px-3 rounded">
                            Clear
                        </button>
                    </div>

                    <div id="propertyStatus"></div>
                </div>
            </div>

            <div class="text-sm text-gray-400 pt-2 border-t border-gray-700">
                <p>Min Elevation: <span id="minElevation" class="font-semibold text-gray-200">N/A</span></p>
                <p>Max Elevation: <span id="maxElevation" class="font-semibold text-gray-200">N/A</span></p>
            </div>
        </div>
    </div>

    <div id="loader"><div class="spinner"></div><span>Processing Terrain...</span></div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const ui = {
            fileInput: document.getElementById('jsonFile'),
            loader: document.getElementById('loader'),
            controlsPanel: document.getElementById('controls'),
            veSlider: document.getElementById('verticalExaggeration'),
            veValueLabel: document.getElementById('veValue'),
            minElevationLabel: document.getElementById('minElevation'),
            maxElevationLabel: document.getElementById('maxElevation'),
            colorSchemeSelect: document.getElementById('colorScheme'),
            wireframeToggle: document.getElementById('wireframeToggle'),
            contourToggle: document.getElementById('contourToggle'),
            contourInterval: document.getElementById('contourInterval'),
            // Property line controls
            propertyToggle: document.getElementById('propertyToggle'),
            propertyControls: document.getElementById('propertyControls'),
            propertyColor: document.getElementById('propertyColor'),
            propertyWidth: document.getElementById('propertyWidth'),
            propertyHeight: document.getElementById('propertyHeight'),
            pwValueLabel: document.getElementById('pwValue'),
            phValueLabel: document.getElementById('phValue'),
            updatePropertyBtn: document.getElementById('updateProperty'),
            clearPropertyBtn: document.getElementById('clearProperty'),
            propertyStatus: document.getElementById('propertyStatus'),
            // GPS coordinate inputs
            lat1: document.getElementById('lat1'),
            lon1: document.getElementById('lon1'),
            lat2: document.getElementById('lat2'),
            lon2: document.getElementById('lon2'),
            lat3: document.getElementById('lat3'),
            lon3: document.getElementById('lon3'),
            lat4: document.getElementById('lat4'),
            lon4: document.getElementById('lon4'),
        };

        let scene, camera, renderer, controls, terrainGroup, terrainMesh, contoursGroup, propertyGroup, rawContourData, directionalLight;
        let terrainBounds, terrainTransform;

        // Coordinate system setup for Ontario (UTM Zone 17N)
        const terrainCRS = '+proj=utm +zone=17 +datum=NAD83 +units=m +no_defs';
        const gpsCRS = '+proj=longlat +datum=WGS84 +no_defs';

        const colorSchemes = {
            topographic: { ramp: [new THREE.Color(0x0077be), new THREE.Color(0x52b531), new THREE.Color(0xfde945), new THREE.Color(0xc13723)] },
            earth: { ramp: [new THREE.Color(0x2c5234), new THREE.Color(0x9c7e4f), new THREE.Color(0xd4c2ad), new THREE.Color(0xffffff)] },
            grayscale: { ramp: [new THREE.Color(0x101010), new THREE.Color(0x606060), new THREE.Color(0xc0c0c0), new THREE.Color(0xffffff)] },
            arctic: { ramp: [new THREE.Color(0x2E4A62), new THREE.Color(0x69A2B0), new THREE.Color(0xDDEBF0), new THREE.Color(0xffffff)] },
            volcanic: { ramp: [new THREE.Color(0x1A090D), new THREE.Color(0x5C1F1E), new THREE.Color(0xE04E1F), new THREE.Color(0xF2C263)] },
            desert: { ramp: [new THREE.Color(0x8C6B4F), new THREE.Color(0xD8A86A), new THREE.Color(0xF7DCB4), new THREE.Color(0xFFF2E1)] }
        };

        function init() {
            const canvas = document.getElementById('container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);

            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 1, 20000);
            camera.position.set(600, 600, 600);

            renderer = new THREE.WebGLRenderer({ antialias: true, canvas: canvas });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0,0,0);

            directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(400, 500, 300);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left   = -5000;
            directionalLight.shadow.camera.right  =  5000;
            directionalLight.shadow.camera.top    =  5000;
            directionalLight.shadow.camera.bottom = -5000;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            scene.add(directionalLight);

            const hemiLight = new THREE.HemisphereLight(0x88aaff, 0x444466, 0.5);
            scene.add(hemiLight);

            // Initialize property group
            propertyGroup = new THREE.Group();
            scene.add(propertyGroup);

            setupEventListeners();
            animate();
        }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            ui.fileInput.addEventListener('change', onFileSelect);
            ui.veSlider.addEventListener('input', onVeSliderChange);
            ui.colorSchemeSelect.addEventListener('change', onColorSchemeChange);
            ui.wireframeToggle.addEventListener('change', onWireframeToggle);
            ui.contourToggle.addEventListener('change', onContourToggle);
            ui.contourInterval.addEventListener('input', onContourIntervalChange);

            // Property line event listeners
            ui.propertyToggle.addEventListener('change', onPropertyToggle);
            ui.propertyWidth.addEventListener('input', onPropertyWidthChange);
            ui.propertyHeight.addEventListener('input', onPropertyHeightChange);
            ui.updatePropertyBtn.addEventListener('click', updatePropertyLines);
            ui.clearPropertyBtn.addEventListener('click', clearPropertyLines);

            // Auto-update on coordinate changes
            [ui.lat1, ui.lon1, ui.lat2, ui.lon2, ui.lat3, ui.lon3, ui.lat4, ui.lon4].forEach(input => {
                input.addEventListener('input', debounce(updatePropertyLines, 500));
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    showLoader(true);
                    setTimeout(() => {
                        createSceneContent(data);
                        showLoader(false);
                    }, 50);
                } catch (error) {
                    alert('Error parsing JSON file.');
                    console.error(error);
                    showLoader(false);
                }
            };
            reader.readAsText(file);
        }

        function onVeSliderChange() {
            const value = parseFloat(ui.veSlider.value);
            ui.veValueLabel.textContent = value.toFixed(1);
            if (terrainGroup) {
                terrainGroup.scale.y = value;
            }
            // Update property lines to match terrain scale
            updatePropertyLines();
        }

        function onColorSchemeChange() {
            if (terrainMesh && terrainMesh.material.userData.shader) {
                const scheme = colorSchemes[ui.colorSchemeSelect.value];
                terrainMesh.material.userData.shader.uniforms.c1.value = scheme.ramp[0];
                terrainMesh.material.userData.shader.uniforms.c2.value = scheme.ramp[1];
                terrainMesh.material.userData.shader.uniforms.c3.value = scheme.ramp[2];
                terrainMesh.material.userData.shader.uniforms.c4.value = scheme.ramp[3];
            }
        }

        function onWireframeToggle() {
            if (terrainMesh) {
                terrainMesh.material.wireframe = ui.wireframeToggle.checked;
            }
        }

        function onContourToggle() {
            if (contoursGroup) contoursGroup.visible = ui.contourToggle.checked;
        }

        function onContourIntervalChange() {
            drawContours();
        }

        function onPropertyToggle() {
            if (propertyGroup) {
                propertyGroup.visible = ui.propertyToggle.checked;
            }
        }

        function onPropertyWidthChange() {
            const value = parseInt(ui.propertyWidth.value);
            ui.pwValueLabel.textContent = value;
            updatePropertyLineStyle();
        }

        function onPropertyHeightChange() {
            const value = parseFloat(ui.propertyHeight.value);
            ui.phValueLabel.textContent = value.toFixed(1);
            updatePropertyLines();
        }

        function showLoader(visible) {
            ui.loader.style.display = visible ? 'flex' : 'none';
        }

        function createSceneContent(data) {
            if (terrainGroup) {
                scene.remove(terrainGroup);
                if (terrainMesh) {
                    terrainMesh.geometry.dispose();
                    terrainMesh.material.dispose();
                }
            }

            terrainGroup = new THREE.Group();
            scene.add(terrainGroup);

            // Store terrain bounds for property line validation
            terrainBounds = {
                minX: Number.POSITIVE_INFINITY,
                maxX: Number.NEGATIVE_INFINITY,
                minY: Number.POSITIVE_INFINITY,
                maxY: Number.NEGATIVE_INFINITY,
                minZ: data.minElevation,
                maxZ: data.maxElevation
            };

            // Calculate terrain bounds from vertices
            for (let i = 0; i < data.vertices.length; i += 3) {
                const x = data.vertices[i];
                const y = data.vertices[i + 1]; // northing
                terrainBounds.minX = Math.min(terrainBounds.minX, x);
                terrainBounds.maxX = Math.max(terrainBounds.maxX, x);
                terrainBounds.minY = Math.min(terrainBounds.minY, y);
                terrainBounds.maxY = Math.max(terrainBounds.maxY, y);
            }

            createTerrainMesh(data);
            
            rawContourData = data.contours || [];
            contoursGroup = new THREE.Group();
            terrainGroup.add(contoursGroup);
            drawContours();
            onContourToggle();
            onVeSliderChange();

            ui.minElevationLabel.textContent = `${data.minElevation.toFixed(2)}m`;
            ui.maxElevationLabel.textContent = `${data.maxElevation.toFixed(2)}m`;
            ui.controlsPanel.classList.remove('hidden');
            
            const box = new THREE.Box3().setFromObject(terrainMesh);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            camera.position.set(center.x + size.x * 1.2, center.y + size.y * 1.2, center.z + size.z * 1.2);
            controls.target.copy(center);
        }

        function createTerrainMesh(data) {
            const { width, height, vertices, minElevation, maxElevation } = data;
            
            const geometry = new THREE.BufferGeometry();
            
            const threeVertices = new Float32Array(width * height * 3);
            const colors = new Float32Array(width * height * 3);
            
            for (let i = 0; i < (width * height); i++) {
                const x = vertices[i*3];
                const z_northing = vertices[i*3+1];
                const y_elevation = vertices[i*3+2];

                threeVertices[i*3]   = x;
                threeVertices[i*3+1] = y_elevation;
                threeVertices[i*3+2] = -z_northing;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(threeVertices, 3));

            const indices = [];
            for (let i = 0; i < height - 1; i++) {
                for (let j = 0; j < width - 1; j++) {
                    const a = i * width + j;
                    const b = i * width + (j + 1);
                    const c = (i + 1) * width + j;
                    const d = (i + 1) * width + (j + 1);
                    indices.push(a, c, b);
                    indices.push(b, c, d);
                }
            }
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            
            const scheme = colorSchemes[ui.colorSchemeSelect.value];
            const material = new THREE.MeshStandardMaterial({
                flatShading: false,
                side: THREE.DoubleSide,
                wireframe: ui.wireframeToggle.checked,
                vertexColors: true
            });
            
            const positionAttribute = geometry.getAttribute('position');
            const colorsAttribute = new THREE.BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
            const tempColor = new THREE.Color();
            
            for (let i = 0; i < positionAttribute.count; i++) {
                const elevation = positionAttribute.getY(i);
                const heightT = THREE.MathUtils.clamp((elevation - minElevation) / (maxElevation - minElevation), 0.0, 1.0);
                
                let ramp;
                if (heightT < 0.33) {
                    ramp = tempColor.clone().lerpColors(scheme.ramp[0], scheme.ramp[1], heightT / 0.33);
                } else if (heightT < 0.66) {
                    ramp = tempColor.clone().lerpColors(scheme.ramp[1], scheme.ramp[2], (heightT - 0.33) / 0.33);
                } else {
                    ramp = tempColor.clone().lerpColors(scheme.ramp[2], scheme.ramp[3], (heightT - 0.66) / 0.34);
                }
                colorsAttribute.setXYZ(i, ramp.r, ramp.g, ramp.b);
            }
            geometry.setAttribute('color', colorsAttribute);

            terrainMesh = new THREE.Mesh(geometry, material);
            terrainMesh.receiveShadow = true;
            terrainMesh.castShadow = true;
            terrainGroup.add(terrainMesh);
        }

        function drawContours() {
            if (!contoursGroup || !rawContourData) return;

            while (contoursGroup.children.length) {
                contoursGroup.remove(contoursGroup.children[0]);
            }

            const interval = parseInt(ui.contourInterval.value, 10) || 1;
            const material = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 1 });

            rawContourData.forEach(contour => {
                if (Math.abs(contour.level % interval) < 0.01 || Math.abs(contour.level % interval - interval) < 0.01) {
                    const geometry = new THREE.BufferGeometry();
                    const originalVerts = new Float32Array(contour.vertices);
                    const swizzledVerts = new Float32Array(originalVerts.length);

                    for (let i = 0; i < originalVerts.length; i += 3) {
                        swizzledVerts[i]     = originalVerts[i];
                        swizzledVerts[i + 1] = originalVerts[i + 2];
                        swizzledVerts[i + 2] = -originalVerts[i + 1];
                    }
                    
                    geometry.setAttribute('position', new THREE.BufferAttribute(swizzledVerts, 3));
                    const line = new THREE.Line(geometry, material);
                    contoursGroup.add(line);
                }
            });
        }

        // Property line functions
        function convertGPSToTerrain(lat, lon) {
            try {
                // Convert GPS to UTM coordinates
                const utmCoords = proj4(gpsCRS, terrainCRS, [parseFloat(lon), parseFloat(lat)]);
                return { x: utmCoords[0], y: utmCoords[1] };
            } catch (error) {
                console.error('Coordinate conversion error:', error);
                return null;
            }
        }

        function validateCoordinates() {
            const coords = [];
            const inputs = [
                [ui.lat1.value, ui.lon1.value],
                [ui.lat2.value, ui.lon2.value],
                [ui.lat3.value, ui.lon3.value],
                [ui.lat4.value, ui.lon4.value]
            ];

            for (let i = 0; i < inputs.length; i++) {
                const [lat, lon] = inputs[i];
                if (!lat || !lon) {
                    return { valid: false, message: `Missing coordinates for corner ${i + 1}` };
                }

                const latNum = parseFloat(lat);
                const lonNum = parseFloat(lon);

                if (isNaN(latNum) || isNaN(lonNum)) {
                    return { valid: false, message: `Invalid coordinates for corner ${i + 1}` };
                }

                if (latNum < -90 || latNum > 90) {
                    return { valid: false, message: `Invalid latitude for corner ${i + 1} (must be -90 to 90)` };
                }

                if (lonNum < -180 || lonNum > 180) {
                    return { valid: false, message: `Invalid longitude for corner ${i + 1} (must be -180 to 180)` };
                }

                const terrainCoord = convertGPSToTerrain(latNum, lonNum);
                if (!terrainCoord) {
                    return { valid: false, message: `Coordinate conversion failed for corner ${i + 1}` };
                }

                coords.push(terrainCoord);
            }

            return { valid: true, coords: coords };
        }

        function getElevationAtPoint(x, y) {
            if (!terrainMesh) return 0;

            // Use raycasting to find elevation at terrain coordinates
            const raycaster = new THREE.Raycaster();
            const origin = new THREE.Vector3(x, 1000, -y); // High Y position, negate Y for coordinate system
            const direction = new THREE.Vector3(0, -1, 0); // Cast downward
            
            raycaster.set(origin, direction);
            const intersects = raycaster.intersectObject(terrainMesh);
            
            if (intersects.length > 0) {
                return intersects[0].point.y;
            }
            
            // Fallback: use terrain bounds average elevation
            return (terrainBounds.minZ + terrainBounds.maxZ) / 2;
        }

        function updatePropertyLines() {
            if (!terrainMesh) return;

            const validation = validateCoordinates();
            
            if (!validation.valid) {
                showStatus(validation.message, 'error');
                return;
            }

            const coords = validation.coords;
            const heightOffset = parseFloat(ui.propertyHeight.value);
            const lineWidth = parseInt(ui.propertyWidth.value);
            const color = ui.propertyColor.value;
            
            // Clear existing property lines
            clearPropertyLines();
            
            // Create property boundary lines
            const material = new THREE.LineBasicMaterial({ 
                color: new THREE.Color(color),
                linewidth: lineWidth
            });

            // Create lines connecting the corners (closed loop)
            const lineVertices = [];
            for (let i = 0; i < coords.length; i++) {
                const coord = coords[i];
                const elevation = getElevationAtPoint(coord.x, coord.y);
                const adjustedHeight = (elevation + heightOffset) * (terrainGroup ? terrainGroup.scale.y : 1);
                
                // Add multiple points for smoother curves if needed
                lineVertices.push(coord.x, adjustedHeight, -coord.y);
            }
            
            // Close the loop by adding the first point again
            if (coords.length > 0) {
                const firstCoord = coords[0];
                const elevation = getElevationAtPoint(firstCoord.x, firstCoord.y);
                const adjustedHeight = (elevation + heightOffset) * (terrainGroup ? terrainGroup.scale.y : 1);
                lineVertices.push(firstCoord.x, adjustedHeight, -firstCoord.y);
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(lineVertices, 3));
            
            const line = new THREE.Line(geometry, material);
            propertyGroup.add(line);

            // Add corner markers
            const markerGeometry = new THREE.SphereGeometry(2, 8, 6);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: color });
            
            coords.forEach((coord, index) => {
                const elevation = getElevationAtPoint(coord.x, coord.y);
                const adjustedHeight = (elevation + heightOffset + 1) * (terrainGroup ? terrainGroup.scale.y : 1);
                
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(coord.x, adjustedHeight, -coord.y);
                propertyGroup.add(marker);
            });

            showStatus('Property lines updated successfully', 'success');
        }

        function updatePropertyLineStyle() {
            if (propertyGroup.children.length === 0) return;
            
            const lineWidth = parseInt(ui.propertyWidth.value);
            const color = new THREE.Color(ui.propertyColor.value);
            
            propertyGroup.children.forEach(child => {
                if (child.material) {
                    child.material.color.copy(color);
                    if (child.material.linewidth !== undefined) {
                        child.material.linewidth = lineWidth;
                    }
                }
            });
        }

        function clearPropertyLines() {
            while (propertyGroup.children.length) {
                const child = propertyGroup.children[0];
                propertyGroup.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            }
            
            // Also clear preview markers when clearing property lines
            previewMarkers.forEach(marker => {
                scene.remove(marker);
                if (marker.geometry) marker.geometry.dispose();
                if (marker.material) marker.material.dispose();
            });
            previewMarkers = [];
            
            showStatus('Property lines cleared', 'success');
        }

        function showStatus(message, type) {
            const statusEl = ui.propertyStatus;
            statusEl.textContent = message;
            statusEl.className = type === 'error' ? 'error-message' : 'success-message';
            
            setTimeout(() => {
                statusEl.textContent = '';
                statusEl.className = '';
            }, 3000);
        }

        // Default coordinate functions
        function loadDefaultCoordinates() {
            // Default GPS coordinates for sample property
            const defaultCoords = {
                corner1: { lat: '44.751263256468434', lon: '-79.90901308951105' }, // NW
                corner2: { lat: '44.75101191641531', lon: '-79.90895445859564' },   // NE  
                corner3: { lat: '44.75093093667837', lon: '-79.90866110504524' },   // SE
                corner4: { lat: '44.75066053265817', lon: '-79.90883799167594' }    // SW
            };
            
            // Populate input fields
            ui.lat1.value = defaultCoords.corner1.lat;
            ui.lon1.value = defaultCoords.corner1.lon;
            ui.lat2.value = defaultCoords.corner2.lat;
            ui.lon2.value = defaultCoords.corner2.lon;
            ui.lat3.value = defaultCoords.corner3.lat;
            ui.lon3.value = defaultCoords.corner3.lon;
            ui.lat4.value = defaultCoords.corner4.lat;
            ui.lon4.value = defaultCoords.corner4.lon;
            
            // Clear any existing clicked corners and preview markers
            clearClickedCorners();
            
            // Debug: Check coordinate conversion
            if (terrainCenter) {
                console.log('Testing coordinate conversion:');
                const testCoord = convertGPSToTerrain(44.751263256468434, -79.90901308951105);
                console.log('GPS to terrain:', testCoord);
                if (testCoord) {
                    const backToGPS = convertTerrainToGPS(testCoord.x, testCoord.y);
                    console.log('Back to GPS:', backToGPS);
                }
            }
            
            // Auto-update property lines
            updatePropertyLines();
            
            showStatus('Sample property coordinates loaded', 'success');
        }

        function clearCoordinateInputs() {
            // Clear all coordinate input fields
            [ui.lat1, ui.lon1, ui.lat2, ui.lon2, ui.lat3, ui.lon3, ui.lat4, ui.lon4].forEach(input => {
                if (input) input.value = '';
            });
            
            // Clear clicked corners and preview markers
            clearClickedCorners();
            
            showStatus('All coordinate inputs cleared', 'success');
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        init();
    </script>
</body>
</html>